#![no_std]
#![no_main]

use {defmt_rtt as _, panic_probe as _};

#[rtic::app(device = stm32f1xx_hal::pac, dispatchers = [EXTI15_10])]
mod app {
    use defmt::info;
    use stm32f1xx_hal::{prelude::*, rtc::Rtc};

    #[shared]
    struct Shared {}

    #[local]
    struct Local {
        led: PC13<Output<PushPull>>,
        led_on: bool,
        rtc: Rtc,
    }

    #[init]
    fn init(cx: init::Context) -> (Shared, Local) {
        let dp = cx.device;
        let mut pwr = dp.PWR;
        let rcc = dp.RCC.constrain();

        // Set up the GPIO pin
        let mut gpioc = dp.GPIOC.split();
        let mut led = gpioc.pc13.into_push_pull_output(&mut gpioc.crh);

        // Set up the RTC
        // Enable writes to the backup domain
        let mut backup_domain = rcc.bkp.constrain(dp.BKP, &mut pwr);
        // Start the RTC
        let mut rtc = Rtc::new(dp.RTC, &mut backup_domain);
        let mut led_on = false;
        (Shared {}, Local { led, led_on, rtc })
    }

    #[idle(local = [led, led_on, rtc])]
    fn idle(cx: idle::Context) -> ! {
        let idle::SharedResources { .. } = cx.local;

        loop {
            // Set the current time to 0
            rtc.set_time(0);
            // Trigger the alarm in 5 seconds
            rtc.set_alarm(5);
            block!(rtc.wait_alarm()).unwrap();
            if led_on {
                led.set_low();
                led_on = false;
            } else {
                led.set_high();
                led_on = true;
            }
        }
    }
}
